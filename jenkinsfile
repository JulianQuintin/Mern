pipeline {
    agent {
        docker {
            image 'docker:24.0.7'
            args '-v /var/run/docker.sock:/var/run/docker.sock -v /usr/local/bin/docker-compose:/usr/local/bin/docker-compose'
        }
    }

    tools {
        git 'Default-Git' // Nombre exacto de tu herramienta Git configurada en Jenkins
    }

    options {
        timeout(time: 30, unit: 'MINUTES')
        buildDiscarder(logRotator(numToKeepStr: '10'))
    }

    environment {
        DOCKER_IMAGE = 'julianquintin/mern-mysql-crud-master'
        DOCKER_TAG = "${env.BUILD_NUMBER}"
        K8S_NAMESPACE = 'mern-crud-ns'
        APP_NAME = 'mern-crud-app'
        DOCKERHUB_CREDS = credentials('dockerhub-creds')
        KUBECONFIG_FILE = credentials('minikube-config')
    }

    stages {
        stage('Checkout Code') {
            steps {
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: 'main']],
                    extensions: [
                        [$class: 'CleanBeforeCheckout'],
                        [$class: 'CloneOption', depth: 1, shallow: true]
                    ],
                    userRemoteConfigs: [[
                        url: 'https://github.com/JulianQuintin/Mern.git',
                        credentialsId: 'GitHubtoken2'
                    ]]
                ])
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    sh "docker build -t ${DOCKER_IMAGE}:${DOCKER_TAG} ./docker"
                }
            }
        }

        stage('Run Tests') {
            steps {
                script {
                    try {
                        sh '/usr/local/bin/docker-compose -f docker-compose.test.yml up --build --abort-on-container-exit --exit-code-from test'
                    } finally {
                        sh '/usr/local/bin/docker-compose -f docker-compose.test.yml down -v'
                    }
                }
            }
        }

        stage('Push to Docker Hub') {
            steps {
                script {
                    sh """
                        echo "$DOCKERHUB_CREDS_PSW" | docker login -u "$DOCKERHUB_CREDS_USR" --password-stdin
                        docker push ${DOCKER_IMAGE}:${DOCKER_TAG}
                    """
                    if (env.BRANCH_NAME == 'main' || env.BRANCH_NAME == 'master') {
                        sh """
                            docker tag ${DOCKER_IMAGE}:${DOCKER_TAG} ${DOCKER_IMAGE}:latest
                            docker push ${DOCKER_IMAGE}:latest
                        """
                    }
                }
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                script {
                    withEnv(["KUBECONFIG=${KUBECONFIG_FILE}"]) {
                        sh """
                            kubectl apply -f k8s/namespace.yaml || true
                            kubectl apply -f k8s/configmap.yaml
                            kubectl apply -f k8s/secrets.yaml
                            kubectl apply -f k8s/mysql-deployment.yaml
                            kubectl rollout status deployment/mysql -n ${K8S_NAMESPACE} --timeout=300s
                            kubectl apply -f k8s/app-deployment.yaml
                            kubectl apply -f k8s/service.yaml
                            kubectl set image deployment/${APP_NAME} ${APP_NAME}=${DOCKER_IMAGE}:${DOCKER_TAG} -n ${K8S_NAMESPACE}
                            kubectl rollout status deployment/${APP_NAME} -n ${K8S_NAMESPACE} --timeout=300s
                        """
                    }
                }
            }
        }

        stage('Smoke Test') {
            steps {
                script {
                    retry(3) {
                        def SERVICE_IP = sh(
                            script: "kubectl get svc ${APP_NAME}-service -n ${K8S_NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' --wait",
                            returnStdout: true
                        ).trim()

                        if (!SERVICE_IP) {
                            error("No se pudo obtener la IP del servicio")
                        }
                        sh "curl --retry 3 --retry-delay 5 --connect-timeout 10 -sSf http://${SERVICE_IP}/api/health"
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                sh '/usr/local/bin/docker-compose -f docker-compose.test.yml down -v || true'
                sh 'docker system prune -f || true'
                
                // Notificaci√≥n de Slack (requiere plugin instalado)
                def SLACK_CHANNEL = '#build-notifications'
                def status = currentBuild.currentResult
                def color = (status == 'SUCCESS') ? 'good' : 'danger'
                
                slackSend(
                    channel: SLACK_CHANNEL,
                    color: color,
                    message: "Build ${status}: ${env.JOB_NAME} #${env.BUILD_NUMBER}\n" +
                            "Docker Image: ${DOCKER_IMAGE}:${DOCKER_TAG}\n" +
                            "K8s Namespace: ${K8S_NAMESPACE}\n" +
                            "URL: ${env.BUILD_URL}"
                )
            }
        }
    }
}