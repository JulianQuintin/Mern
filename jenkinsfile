pipeline {
    agent any

    environment {
        DOCKER_CMD = '/usr/local/bin/docker'
        KUBECTL_CMD = '/usr/local/bin/kubectl'
        DOCKER_IMAGE = "julianquintin/mern-mysql-crud-master:${env.BUILD_NUMBER}"
        MINIKUBE_PROFILE = "mern-cluster"  // Nombre único para este cluster
    }

    stages {
        stage('Start Minikube Cluster') {
            steps {
                script {
                    sh """
                        # Verificar si Minikube está instalado
                        if ! command -v minikube &> /dev/null; then
                            echo "Minikube no está instalado"
                            exit 1
                        fi

                        # Iniciar Minikube si no está corriendo
                        if ! minikube status -p ${MINIKUBE_PROFILE} &> /dev/null; then
                            minikube start -p ${MINIKUBE_PROFILE} --driver=docker \
                                --cpus=4 --memory=8192 --disk-size=20g
                        fi

                        # Configurar el entorno
                        eval \$(minikube docker-env -p ${MINIKUBE_PROFILE})
                        export KUBECONFIG=\$(minikube kubectl config view -p ${MINIKUBE_PROFILE} --flatten)
                    """
                }
            }
        }

        stage('Checkout Code') {
            steps {
                checkout([...]) // Mantén tu configuración actual de checkout
            }
        }

        stage('Build Docker Image in Minikube') {
            steps {
                script {
                    sh """
                        # Construir dentro del entorno Docker de Minikube
                        docker build -t ${env.DOCKER_IMAGE} -f dockerfile .
                    """
                }
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                script {
                    sh """
                        # Asegurar que el namespace existe
                        kubectl create namespace mern-crud-ns --dry-run=client -o yaml | kubectl apply -f -

                        # Aplicar los manifiestos con política de imagen local
                        kubectl apply -f k8s/namespace.yaml
                        kubectl apply -f k8s/mysql-deployment.yaml -n mern-crud-ns
                        kubectl patch deployment mern-crud-app -n mern-crud-ns \
                            -p '{"spec":{"template":{"spec":{"containers":[{"name":"mern-crud-app","imagePullPolicy":"Never"}]}}}}' || true
                        kubectl apply -f k8s/app-deployment.yaml -n mern-crud-ns
                        kubectl apply -f k8s/service.yaml -n mern-crud-ns

                        # Actualizar imagen
                        kubectl set image deployment/mern-crud-app mern-crud-app=${env.DOCKER_IMAGE} -n mern-crud-ns

                        # Esperar despliegue con manejo de errores
                        timeout 600 bash -c "
                            while ! kubectl rollout status deployment/mern-crud-app -n mern-crud-ns --timeout=60s; do
                                echo '=== Estado actual ===';
                                kubectl get pods -n mern-crud-ns -o wide;
                                echo '=== Logs de pods fallidos ===';
                                kubectl logs -n mern-crud-ns -l app=mern-crud-app --all-containers=true --tail=50 || true;
                                echo '=== Reintentando en 10 segundos ===';
                                sleep 10;
                            done
                        "
                    """
                }
            }
        }
    }

    post {
        always {
            echo "Pipeline execution completed with status: ${currentBuild.currentResult}"
            sh "docker system prune -f || true"
        }
        failure {
            script {
                // Solo intentar diagnóstico si Minikube está activo
                if (sh(script: "minikube status -p ${env.MINIKUBE_PROFILE} &> /dev/null", returnStatus: true) == 0) {
                    sh """
                        echo '=== INFORMACIÓN DE DIAGNÓSTICO ==='
                        minikube status -p ${env.MINIKUBE_PROFILE}
                        kubectl config current-context
                        kubectl cluster-info
                        kubectl get all -n mern-crud-ns
                        kubectl describe deployment mern-crud-app -n mern-crud-ns
                        kubectl get events -n mern-crud-ns --sort-by=.metadata.creationTimestamp
                    """
                } else {
                    echo "Minikube no está disponible para diagnóstico"
                }
            }
        }
    }
}